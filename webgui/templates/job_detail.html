{% extends "base.html" %}

{% block title %}Job #{{ job.id }} - HiAni DL{% endblock %}

{% block content %}
<div class="row">
    <div class="col-12">
        <div class="card shadow">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h4 class="mb-0"><i class="bi bi-info-circle"></i> Job #{{ job.id }}</h4>
                <div>
                    <a href="/jobs" class="btn btn-light btn-sm">
                        <i class="bi bi-arrow-left"></i> Back to Jobs
                    </a>
                </div>
            </div>
            <div class="card-body">
                <!-- Job Status -->
                <div class="row mb-4">
                    <div class="col-md-6">
                        <h5>Status</h5>
                        <div id="statusBadge">
                            {% if job.status == 'queued' %}
                            <span class="badge bg-secondary status-badge fs-5">
                                <i class="bi bi-hourglass"></i> Queued
                            </span>
                            {% elif job.status == 'running' %}
                            <span class="badge bg-primary status-badge fs-5">
                                <i class="bi bi-arrow-repeat"></i> Running
                            </span>
                            {% elif job.status == 'success' %}
                            <span class="badge bg-success status-badge fs-5">
                                <i class="bi bi-check-circle"></i> Success
                            </span>
                            {% elif job.status == 'failed' %}
                            <span class="badge bg-danger status-badge fs-5">
                                <i class="bi bi-x-circle"></i> Failed
                            </span>
                            {% elif job.status == 'canceled' %}
                            <span class="badge bg-warning text-dark status-badge fs-5">
                                <i class="bi bi-dash-circle"></i> Canceled
                            </span>
                            {% endif %}
                        </div>
                    </div>
                    <div class="col-md-6">
                        <h5>Progress</h5>
                        <div class="progress" style="height: 30px;">
                            <div
                                id="progressBar"
                                class="progress-bar
                                {% if job.status == 'success' %}bg-success
                                {% elif job.status == 'failed' %}bg-danger
                                {% elif job.status == 'canceled' %}bg-warning
                                {% else %}progress-bar-striped progress-bar-animated
                                {% endif %}"
                                role="progressbar"
                                style="width: {{ job.progress_percent }}%"
                                aria-valuenow="{{ job.progress_percent }}"
                                aria-valuemin="0"
                                aria-valuemax="100"
                            >
                                <span id="progressText">{{ job.progress_percent }}%</span>
                            </div>
                        </div>
                        <div class="mt-2">
                            <small class="text-muted" id="stageText">
                                {% if job.stage %}Stage: {{ job.stage }}{% endif %}
                            </small>
                            <br>
                            <small class="text-muted" id="progressDetailText">
                                {% if job.progress_text %}{{ job.progress_text }}{% endif %}
                            </small>
                        </div>
                    </div>
                </div>

                <!-- Job Details -->
                <div class="row mb-4">
                    <div class="col-12">
                        <h5>Details</h5>
                        <table class="table table-sm">
                            <tr>
                                <th style="width: 150px;">URL:</th>
                                <td><a href="{{ job.url }}" target="_blank">{{ job.url }}</a></td>
                            </tr>
                            <tr>
                                <th>Profile:</th>
                                <td>{{ job.profile or 'Default' }}</td>
                            </tr>
                            {% if job.extra_args %}
                            <tr>
                                <th>Extra Args:</th>
                                <td><code>{{ job.extra_args | format_episode_args }}</code></td>
                            </tr>
                            {% endif %}
                            <tr>
                                <th>Created:</th>
                                <td>{{ job.created_at | format_datetime }}</td>
                            </tr>
                            <tr>
                                <th>Started:</th>
                                <td>{{ job.started_at | format_datetime }}</td>
                            </tr>
                            <tr>
                                <th>Finished:</th>
                                <td>{{ job.finished_at | format_datetime }}</td>
                            </tr>
                            {% if job.error_message %}
                            <tr>
                                <th>Error:</th>
                                <td class="text-danger">{{ job.error_message }}</td>
                            </tr>
                            {% endif %}
                        </table>
                    </div>
                </div>

                <!-- Actions -->
                <div class="row mb-4">
                    <div class="col-12">
                        <h5>Actions</h5>
                        <div class="btn-group" role="group">
                            {% if job.status in ['queued', 'running'] %}
                            <button class="btn btn-warning" onclick="cancelJob({{ job.id }})">
                                <i class="bi bi-x-circle"></i> Cancel Job
                            </button>
                            {% endif %}
                            {% if job.log_file %}
                            <a href="/api/jobs/{{ job.id }}/log" class="btn btn-outline-accent" download>
                                <i class="bi bi-download"></i> Download Log
                            </a>
                            <a href="/api/jobs/{{ job.id }}/diagnostics" class="btn btn-outline-secondary" download>
                                <i class="bi bi-file-earmark-zip"></i> Download Diagnostics
                            </a>
                            {% endif %}
                        </div>
                    </div>
                </div>

                <!-- Episodes Progress -->
                <div class="row mb-4" id="episodesSection" style="display: none;">
                    <div class="col-12">
                        <h5>Episodes</h5>
                        <div id="episodesContainer">
                            <div class="text-muted">Loading episodes...</div>
                        </div>
                    </div>
                </div>

                <!-- Live Log Viewer -->
                <div class="row">
                    <div class="col-12">
                        <h5>Live Log</h5>
                        <div class="log-viewer" id="logViewer">
                            {% if job.log_file %}
                            <div class="text-muted">Loading log...</div>
                            {% else %}
                            <div class="text-muted">No log available yet</div>
                            {% endif %}
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
const jobId = {{ job.id }};
let eventSource = null;

// Connect to SSE endpoint for live updates
function connectEventSource() {
    if (eventSource) {
        eventSource.close();
    }

    eventSource = new EventSource(`/api/jobs/${jobId}/events`);

    eventSource.addEventListener('status', (e) => {
        const data = JSON.parse(e.data);
        updateStatus(data);
    });

    eventSource.addEventListener('log', (e) => {
        const data = JSON.parse(e.data);
        appendLog(data.lines);
    });

    eventSource.addEventListener('episodes', (e) => {
        const data = JSON.parse(e.data);
        updateEpisodes(data.episodes);
    });

    eventSource.addEventListener('complete', (e) => {
        const data = JSON.parse(e.data);
        console.log('Job complete:', data.status);
        eventSource.close();
        // Reload page after a delay to show final state
        setTimeout(() => location.reload(), 2000);
    });

    eventSource.addEventListener('error', (e) => {
        console.error('EventSource error:', e);
        eventSource.close();
    });
}

function updateStatus(data) {
    // Update progress bar
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');

    progressBar.style.width = `${data.progress_percent}%`;
    progressBar.setAttribute('aria-valuenow', data.progress_percent);
    progressText.textContent = `${data.progress_percent}%`;

    // Update stage
    const stageText = document.getElementById('stageText');
    if (data.stage) {
        stageText.textContent = `Stage: ${data.stage}`;
    }

    // Update progress detail text
    const progressDetailText = document.getElementById('progressDetailText');
    if (data.progress_text) {
        progressDetailText.textContent = data.progress_text;
    }

    // Update status badge
    const statusBadge = document.getElementById('statusBadge');
    let badgeClass = 'badge status-badge fs-5';
    let badgeIcon = '';
    let badgeText = data.status;

    switch (data.status) {
        case 'queued':
            badgeClass += ' bg-secondary';
            badgeIcon = 'hourglass';
            badgeText = 'Queued';
            break;
        case 'running':
            badgeClass += ' bg-primary';
            badgeIcon = 'arrow-repeat';
            badgeText = 'Running';
            break;
        case 'success':
            badgeClass += ' bg-success';
            badgeIcon = 'check-circle';
            badgeText = 'Success';
            progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
            progressBar.classList.add('bg-success');
            break;
        case 'failed':
            badgeClass += ' bg-danger';
            badgeIcon = 'x-circle';
            badgeText = 'Failed';
            progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
            progressBar.classList.add('bg-danger');
            break;
        case 'canceled':
            badgeClass += ' bg-warning text-dark';
            badgeIcon = 'dash-circle';
            badgeText = 'Canceled';
            progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
            progressBar.classList.add('bg-warning');
            break;
    }

    statusBadge.innerHTML = `<span class="${badgeClass}"><i class="bi bi-${badgeIcon}"></i> ${badgeText}</span>`;
}

/**
 * Progress Component Class
 *
 * Marker Position Math:
 * For N stages, we position markers evenly from 0% to 100% of the bar width.
 * Marker i is positioned at: (i / (N - 1)) Ã— 100%
 * We use CSS left + translateX(-50%) so the marker CENTER sits at that percentage,
 * ensuring the first marker center is at 0% and last at 100%, perfectly aligned
 * with bar edges. A ResizeObserver updates connector widths dynamically.
 */
class ProgressComponent {
    constructor(container, options) {
        this.container = container;
        this.options = options;
        this.stages = options.stages || [];
        this.progressPercent = Math.max(0, Math.min(100, options.progressPercent || 0));
        this.currentStageId = options.currentStageId;
        this.completedStageIds = new Set(options.completedStageIds || []);
        this.stageData = options.stageData || {};
        this.isFailed = options.isFailed || false;

        this.render();
        this.setupResizeObserver();
    }

    getStageStatus(stage) {
        if (this.completedStageIds.has(stage.id)) return 'completed';
        if (this.currentStageId === stage.id) {
            return this.isFailed ? 'failed' : 'active';
        }
        return 'pending';
    }

    getStageIcon(status) {
        if (status === 'completed') {
            return `<svg fill="white" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>`;
        } else if (status === 'failed') {
            return `<svg fill="white" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/></svg>`;
        } else if (status === 'active') {
            return `<svg fill="white" viewBox="0 0 20 20"><circle cx="10" cy="10" r="4"/></svg>`;
        } else {
            return `<svg fill="currentColor" viewBox="0 0 20 20" style="opacity: 0.3;"><circle cx="10" cy="10" r="3"/></svg>`;
        }
    }

    calculateMarkerPosition(index) {
        const N = this.stages.length;
        if (N === 1) return 50;
        // Add 8% padding on each side to move markers inward from borders
        const padding = 8;
        const availableWidth = 100 - (padding * 2);
        return padding + (index / (N - 1)) * availableWidth;
    }

    render() {
        const component = document.createElement('div');
        component.className = 'progress-component';
        component.setAttribute('role', 'region');
        component.setAttribute('aria-label', 'Progress indicator');

        // Progress bar
        const barContainer = document.createElement('div');
        barContainer.className = 'progress-bar-container';
        barContainer.setAttribute('role', 'progressbar');
        barContainer.setAttribute('aria-valuemin', '0');
        barContainer.setAttribute('aria-valuemax', '100');
        barContainer.setAttribute('aria-valuenow', this.progressPercent);
        barContainer.setAttribute('aria-label', `Progress: ${this.progressPercent}%`);

        const barFill = document.createElement('div');
        barFill.className = 'progress-bar-fill';
        if (this.options.status === 'complete') barFill.classList.add('complete');
        if (this.options.status === 'failed') barFill.classList.add('failed');
        barFill.style.width = `${this.progressPercent}%`;

        const percentText = document.createElement('span');
        percentText.className = 'progress-percent-text';
        percentText.textContent = `${this.progressPercent}%`;
        percentText.style.opacity = this.progressPercent < 12 ? '0' : '1';

        barFill.appendChild(percentText);
        barContainer.appendChild(barFill);
        component.appendChild(barContainer);

        // Stage timeline
        const timeline = document.createElement('div');
        timeline.className = 'stage-timeline';
        timeline.setAttribute('role', 'list');
        timeline.setAttribute('aria-label', 'Stage progress');

        // Render connectors
        for (let i = 0; i < this.stages.length - 1; i++) {
            const connector = document.createElement('div');
            connector.className = 'stage-connector';
            connector.dataset.connectorIndex = i;
            timeline.appendChild(connector);
        }

        // Render stage markers
        this.stages.forEach((stage, index) => {
            const status = this.getStageStatus(stage);
            const position = this.calculateMarkerPosition(index);

            const marker = document.createElement('div');
            marker.className = `stage-marker ${status}`;
            marker.style.left = `${position}%`;
            marker.setAttribute('role', 'listitem');
            marker.dataset.markerIndex = index;

            const icon = document.createElement('div');
            icon.className = 'stage-icon';
            icon.innerHTML = this.getStageIcon(status);
            icon.setAttribute('aria-hidden', 'true');

            const label = document.createElement('div');
            label.className = 'stage-label';
            label.textContent = stage.label;

            // Add download details for active downloading stage
            if (status === 'active' && stage.id === 'download_video' && this.stageData.percent) {
                const details = document.createElement('div');
                details.className = 'stage-details';
                details.textContent = `${this.stageData.percent}% of ${this.stageData.size} at ${this.stageData.speed}`;
                marker.appendChild(details);
            }

            const srText = document.createElement('span');
            srText.className = 'sr-only';
            srText.textContent = `${stage.label}: ${status}`;
            marker.appendChild(srText);

            marker.appendChild(icon);
            marker.appendChild(label);
            timeline.appendChild(marker);
        });

        component.appendChild(timeline);

        this.container.innerHTML = '';
        this.container.appendChild(component);

        this.timelineElement = timeline;
        this.updateConnectors();
    }

    updateConnectors() {
        if (!this.timelineElement) return;

        const markers = this.timelineElement.querySelectorAll('.stage-marker');
        const connectors = this.timelineElement.querySelectorAll('.stage-connector');

        markers.forEach((marker, index) => {
            if (index < connectors.length) {
                const nextMarker = markers[index + 1];
                if (nextMarker) {
                    const markerRect = marker.getBoundingClientRect();
                    const nextMarkerRect = nextMarker.getBoundingClientRect();
                    const timelineRect = this.timelineElement.getBoundingClientRect();

                    const startX = markerRect.left - timelineRect.left + (markerRect.width / 2);
                    const endX = nextMarkerRect.left - timelineRect.left + (nextMarkerRect.width / 2);

                    const connector = connectors[index];
                    connector.style.left = `${startX}px`;
                    connector.style.width = `${endX - startX}px`;
                }
            }
        });
    }

    setupResizeObserver() {
        const observer = new ResizeObserver(() => {
            this.updateConnectors();
        });
        observer.observe(this.container);
        this.resizeObserver = observer;
    }

    update(newOptions) {
        this.options = { ...this.options, ...newOptions };
        this.progressPercent = Math.max(0, Math.min(100, newOptions.progressPercent ?? this.progressPercent));
        this.currentStageId = newOptions.currentStageId ?? this.currentStageId;
        this.completedStageIds = new Set(newOptions.completedStageIds ?? this.completedStageIds);
        this.stageData = newOptions.stageData ?? this.stageData;
        this.isFailed = newOptions.isFailed ?? this.isFailed;
        this.render();
    }

    destroy() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }
    }
}

// Store component instances
const episodeComponents = new Map();

// Helper function to get completed stages
function getCompletedStages(currentStatus) {
    const stageOrder = ['get_stream', 'download_video', 'merge_video', 'download_subtitles'];
    const currentIndex = stageOrder.indexOf(currentStatus);
    if (currentStatus === 'complete') return stageOrder;
    return currentIndex > 0 ? stageOrder.slice(0, currentIndex) : [];
}

function updateEpisodes(episodes) {
    if (!episodes || episodes.length === 0) {
        return;
    }

    const episodesSection = document.getElementById('episodesSection');
    episodesSection.style.display = 'block';

    const container = document.getElementById('episodesContainer');

    episodes.forEach(episode => {
        let episodeDiv = document.getElementById(`episode-${episode.id}`);

        // Create episode div if it doesn't exist
        if (!episodeDiv) {
            episodeDiv = document.createElement('div');
            episodeDiv.className = 'episode-item mb-3 p-3 border rounded';
            episodeDiv.id = `episode-${episode.id}`;

            // Create header with title and error message
            const headerDiv = document.createElement('div');
            headerDiv.className = 'd-flex justify-content-between align-items-start mb-3';

            const titleDiv = document.createElement('div');
            titleDiv.innerHTML = `<strong>Episode ${episode.episode_number}</strong>: ${episode.title}`;
            headerDiv.appendChild(titleDiv);

            const errorDiv = document.createElement('div');
            errorDiv.id = `error-${episode.id}`;
            errorDiv.className = 'text-danger small fw-bold';
            errorDiv.style.marginLeft = '10px';
            headerDiv.appendChild(errorDiv);

            episodeDiv.appendChild(headerDiv);

            const progressContainer = document.createElement('div');
            progressContainer.id = `progress-${episode.id}`;
            episodeDiv.appendChild(progressContainer);

            container.appendChild(episodeDiv);
        }

        // Parse stage data
        let stageData = {};
        if (episode.stage_data) {
            try {
                stageData = JSON.parse(episode.stage_data);
            } catch(e) {}
        }

        // Update or create progress component
        const progressContainer = document.getElementById(`progress-${episode.id}`);
        const stages = [
            { id: 'get_stream', label: 'Finding' },
            { id: 'download_video', label: 'Downloading' },
            { id: 'merge_video', label: 'Merging' },
            { id: 'download_subtitles', label: 'Subtitles' }
        ];

        if (episodeComponents.has(episode.id)) {
            episodeComponents.get(episode.id).update({
                progressPercent: episode.progress_percent,
                currentStageId: episode.status === 'complete' ? null : episode.status,
                completedStageIds: getCompletedStages(episode.status),
                stageData: stageData,
                status: episode.status,
                isFailed: episode.status === 'failed'
            });
        } else {
            const component = new ProgressComponent(progressContainer, {
                stages,
                progressPercent: episode.progress_percent,
                currentStageId: episode.status === 'complete' ? null : episode.status,
                completedStageIds: getCompletedStages(episode.status),
                stageData: stageData,
                status: episode.status,
                isFailed: episode.status === 'failed'
            });
            episodeComponents.set(episode.id, component);
        }

        // Update error message
        const errorDiv = document.getElementById(`error-${episode.id}`);
        errorDiv.textContent = episode.error_message || '';
        errorDiv.style.display = episode.error_message ? 'block' : 'none';
    });
}

function appendLog(lines) {
    const logViewer = document.getElementById('logViewer');

    // Clear "loading" message on first log line
    if (logViewer.querySelector('.text-muted')) {
        logViewer.innerHTML = '';
    }

    lines.forEach(line => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'log-line';
        lineDiv.textContent = line;
        logViewer.appendChild(lineDiv);
    });

    // Auto-scroll to bottom
    logViewer.scrollTop = logViewer.scrollHeight;
}

async function cancelJob(jobId) {
    if (!confirm('Are you sure you want to cancel this job?')) {
        return;
    }

    try {
        const response = await fetch(`/api/jobs/${jobId}/cancel`, {
            method: 'POST',
        });

        if (!response.ok) {
            throw new Error('Failed to cancel job');
        }

        alert('Job canceled successfully');
        location.reload();
    } catch (error) {
        alert(`Error: ${error.message}`);
    }
}

// Fetch episodes initially on page load
async function fetchEpisodes() {
    try {
        const response = await fetch(`/api/jobs/${jobId}/episodes`);
        if (response.ok) {
            const episodes = await response.json();
            if (episodes && episodes.length > 0) {
                updateEpisodes(episodes);
            }
        }
    } catch (error) {
        console.error('Error fetching episodes:', error);
    }
}

// Initialize page
fetchEpisodes();

// Start SSE connection if job is active
{% if job.status in ['queued', 'running'] %}
connectEventSource();
{% endif %}
</script>
{% endblock %}
